<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RDR Analysis Dashboard</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
        }
    </script>
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }

        [x-cloak] {
            display: none !important;
        }
    </style>
</head>

<body class="bg-slate-50 dark:bg-slate-900 text-slate-900 dark:text-slate-100 transition-colors duration-200"
    x-data="dashboard()"
    x-init="$watch('darkMode', val => document.documentElement.classList.toggle('dark', val)); document.documentElement.classList.toggle('dark', darkMode)">

    <!-- Sidebar -->
    {{template "sidebar.html" .}}

    <!-- Main Content -->
    <div class="lg:ml-64 min-h-screen flex flex-col transition-all duration-300">

        <!-- Header -->
        {{template "header.html" .}}

        <!-- Content -->
        {{template "dashboard.html" .}}
    </div>

    <!-- Data Injection for Initial State -->
    <script>
        // Go template injection for initial instances list
        const initialInstances = [
            {{ range .Instances }}
        "{{.}}",
            {{ end }}
        ];
    </script>

    <script>
        function dashboard() {
            return {
                sidebarOpen: false,
                currentInstance: null,
                instances: initialInstances || [],
                loading: false,
                data: null,
                error: null,
                charts: {},
                currentTab: 'dashboard',

                // Dark Mode
                darkMode: localStorage.getItem('darkMode') === 'true' || (!('darkMode' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches),

                toggleDarkMode() {
                    this.darkMode = !this.darkMode;
                    localStorage.setItem('darkMode', this.darkMode);
                    document.documentElement.classList.toggle('dark', this.darkMode);
                },

                // Pagination - Largest Keys
                itemsPerPage: 15,
                currentPage: 1,

                // Key Prefix Analysis
                prefixTab: 'hash',
                prefixPage: 1,
                prefixItemsPerPage: 15,

                get prefixTypes() {
                    if (!this.data || !this.data.LargestKeyPrefixes) return [];
                    return Object.keys(this.data.LargestKeyPrefixes).sort();
                },

                get currentPrefixData() {
                    if (!this.data || !this.data.LargestKeyPrefixes || !this.data.LargestKeyPrefixes[this.prefixTab]) return [];
                    return this.data.LargestKeyPrefixes[this.prefixTab];
                },

                get paginatedPrefixes() {
                    const data = this.currentPrefixData;
                    if (!data) return [];
                    const start = (this.prefixPage - 1) * this.prefixItemsPerPage;
                    const end = start + this.prefixItemsPerPage;
                    return data.slice(start, end);
                },

                get prefixTotalPages() {
                    const data = this.currentPrefixData;
                    if (!data) return 0;
                    return Math.ceil(data.length / this.prefixItemsPerPage);
                },

                get prefixVisiblePages() {
                    const total = this.prefixTotalPages;
                    const current = this.prefixPage;
                    const delta = 2;
                    const range = [];
                    const rangeWithDots = [];
                    let l;

                    range.push(1);

                    if (total > 1) {
                        for (let i = current - delta; i <= current + delta; i++) {
                            if (i < total && i > 1) {
                                range.push(i);
                            }
                        }
                        range.push(total);
                    }

                    for (let i of range) {
                        if (l) {
                            if (i - l === 2) {
                                rangeWithDots.push(l + 1);
                            } else if (i - l !== 1) {
                                rangeWithDots.push('...');
                            }
                        }
                        rangeWithDots.push(i);
                        l = i;
                    }
                    return rangeWithDots;
                },

                setPrefixTab(tab) {
                    this.prefixTab = tab;
                    this.prefixPage = 1;
                },

                nextPrefixPage() {
                    if (this.prefixPage < this.prefixTotalPages) {
                        this.prefixPage++;
                    }
                },

                prevPrefixPage() {
                    if (this.prefixPage > 1) {
                        this.prefixPage--;
                    }
                },

                setPrefixPage(page) {
                    this.prefixPage = page;
                },

                // Analysis History Grouping Logic
                expandedNamespaces: JSON.parse(localStorage.getItem('expandedNamespaces')) || [],
                expandedPods: JSON.parse(localStorage.getItem('expandedPods')) || [],

                toggleNamespace(ns) {
                    if (this.expandedNamespaces.includes(ns)) {
                        this.expandedNamespaces = this.expandedNamespaces.filter(n => n !== ns);
                    } else {
                        this.expandedNamespaces.push(ns);
                    }
                    localStorage.setItem('expandedNamespaces', JSON.stringify(this.expandedNamespaces));
                },

                togglePod(podKey) {
                    if (this.expandedPods.includes(podKey)) {
                        this.expandedPods = this.expandedPods.filter(p => p !== podKey);
                    } else {
                        this.expandedPods.push(podKey);
                    }
                    localStorage.setItem('expandedPods', JSON.stringify(this.expandedPods));
                },

                get groupedInstances() {
                    if (!this.instances || this.instances.length === 0) return {};

                    const grouped = {};

                    this.instances.forEach(id => {
                        const parts = id.split('_');
                        // Expect: namespace_pod_timestamp
                        // Handle potential edge cases where fewer parts exist
                        let ns = 'Unknown';
                        let pod = 'Unknown';
                        let ts = id;

                        if (parts.length >= 3) {
                            ns = parts[0];
                            // The pod name might contain underscores? No, usually not.
                            // But timestamp definitely shouldn't if we parsed it right.
                            // However, let's assume the first part is namespace.
                            // The second part is pod.
                            pod = parts[1];
                            // The rest is timestamp/ID
                            ts = parts.slice(2).join('_');
                        } else if (parts.length === 2) {
                            ns = parts[0];
                            pod = parts[1];
                        }

                        if (!grouped[ns]) {
                            grouped[ns] = {};
                        }
                        if (!grouped[ns][pod]) {
                            grouped[ns][pod] = [];
                        }

                        // Parse timestamp for display
                        let displayTime = ts;
                        // Format: YYYY-MMDD_HH
                        // Try to make it readable: 2026-02-06 18:00
                        // Input likely: 2026-0206_02 or similar
                        // Just show the raw timestamp part for now or format if possible
                        try {
                            // If format is YYYY-MMDD_HH
                            // e.g. 2026-0206_02
                            // Convert to 2026-02-06 #02
                            const datePart = ts.split('_')[0]; // 2026-0206
                            if (datePart.length === 9 && datePart[4] === '-') {
                                const y = datePart.substring(0, 4);
                                const m = datePart.substring(5, 7);
                                const d = datePart.substring(7, 9);
                                const suffix = ts.split('_')[1] || '';
                                displayTime = `${y}-${m}-${d} ${suffix ? '#' + suffix : ''}`;
                            }
                        } catch (e) {
                            console.warn('Date parse error', e);
                        }

                        grouped[ns][pod].push({
                            id: id,
                            display: displayTime,
                            fullTs: ts,
                            original: id
                        });
                    });

                    // Sort namespaces
                    const sortedGrouped = {};
                    Object.keys(grouped).sort().forEach(ns => {
                        sortedGrouped[ns] = {};
                        // Sort pods
                        Object.keys(grouped[ns]).sort().forEach(pod => {
                            // Sort instances by timestamp descending (newest first)
                            sortedGrouped[ns][pod] = grouped[ns][pod].sort((a, b) => b.original.localeCompare(a.original));
                        });
                    });

                    return sortedGrouped;
                },

                // K8s Import Logic
                importModalOpen: false,
                discoveryLoading: false,
                discoveryData: [],
                selectedNamespace: '',
                selectedPod: '',
                importPath: '/data/dump.rdb',
                importing: false,
                importStatus: '',
                importProgress: 0,

                openImportModal() {
                    this.importModalOpen = true;
                    this.fetchDiscovery();
                },

                async fetchDiscovery() {
                    this.discoveryLoading = true;
                    try {
                        const res = await fetch('/api/discovery');
                        if (!res.ok) throw new Error('Discovery failed');
                        this.discoveryData = await res.json();
                        // Auto select first if available
                        if (this.discoveryData.length > 0) {
                            this.selectedNamespace = this.discoveryData[0].namespace;
                        }
                    } catch (e) {
                        console.error(e);
                        this.importStatus = 'Failed to load discovery data';
                    } finally {
                        this.discoveryLoading = false;
                    }
                },

                get availablePods() {
                    const ns = this.discoveryData.find(d => d.namespace === this.selectedNamespace);
                    return ns ? ns.pods : [];
                },

                async startImport() {
                    if (!this.selectedNamespace || !this.selectedPod) return;

                    this.importing = true;
                    this.importStatus = 'Starting import job...';
                    this.importProgress = 0;

                    try {
                        const res = await fetch('/api/job/start', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                namespace: this.selectedNamespace,
                                pod: this.selectedPod,
                                path: this.importPath
                            })
                        });

                        if (!res.ok) throw new Error('Failed to start job');
                        const data = await res.json();
                        this.pollJob(data.job_id);
                    } catch (e) {
                        this.importStatus = 'Error: ' + e.message;
                        this.importing = false;
                    }
                },

                async pollJob(id) {
                    const self = this;
                    this.importStatus = 'Initializing...';
                    const poll = setInterval(async () => {
                        try {
                            const res = await fetch(`/api/job/status?id=${id}&_t=${new Date().getTime()}`, { cache: 'no-store' });
                            if (!res.ok) return; // Wait retry
                            const job = await res.json();
                            console.log('Poll Job:', job);

                            // Use server status message
                            // Use server status message
                            self.importStatus = job.status || `Processing... (${job.state})`;
                            if (job.progress) {
                                self.importProgress = job.progress;
                            }

                            // Check 'state' not 'status'
                            if (job.state === 'done') {
                                clearInterval(poll);
                                this.importing = false;
                                this.importModalOpen = false;

                                // Add to local list and select immediately
                                const newInstance = id;
                                if (!this.instances.includes(newInstance)) {
                                    this.instances.push(newInstance);
                                    this.instances.sort();
                                }
                                this.loadInstance(newInstance);
                            } else if (job.state === 'error') {
                                clearInterval(poll);
                                self.importStatus = 'Error: ' + (job.error || job.status);
                                self.importing = false;
                            }
                        } catch (e) {
                            console.error(e);
                            self.importStatus = 'Error: ' + e.message;
                        }
                    }, 1000);
                },

                get paginatedLargestKeys() {
                    if (!this.data || !this.data.LargestKeys) return [];
                    const start = (this.currentPage - 1) * this.itemsPerPage;
                    const end = start + this.itemsPerPage;
                    return this.data.LargestKeys.slice(start, end);
                },


                get totalPages() {
                    if (!this.data || !this.data.LargestKeys) return 0;
                    return Math.ceil(this.data.LargestKeys.length / this.itemsPerPage);
                },

                get visiblePages() {
                    const total = this.totalPages;
                    const current = this.currentPage;
                    const delta = 2;
                    const range = [];
                    const rangeWithDots = [];
                    let l;

                    range.push(1);

                    if (total > 1) {
                        for (let i = current - delta; i <= current + delta; i++) {
                            if (i < total && i > 1) {
                                range.push(i);
                            }
                        }
                        range.push(total);
                    }

                    for (let i of range) {
                        if (l) {
                            if (i - l === 2) {
                                rangeWithDots.push(l + 1);
                            } else if (i - l !== 1) {
                                rangeWithDots.push('...');
                            }
                        }
                        rangeWithDots.push(i);
                        l = i;
                    }
                    return rangeWithDots;
                },

                nextPage() {
                    if (this.currentPage < this.totalPages) {
                        this.currentPage++;
                    }
                },

                prevPage() {
                    if (this.currentPage > 1) {
                        this.currentPage--;
                    }
                },

                setPage(page) {
                    this.currentPage = page;
                },

                init() {
                    // Watch for dark mode changes to update charts
                    this.$watch('darkMode', () => {
                        this.renderCharts();
                    });

                    // Auto-select first instance if available
                    if (this.instances.length > 0 && !this.currentInstance) {
                        this.loadInstance(this.instances[0]);
                    }

                    // Poll for new instances if in dynamic mode
                    setInterval(() => {
                        // In a real app we might fetch this from an API, 
                        // but since we rely on template injection for initial list, 
                        // we'd need an endpoint to get list of instances.
                        // For now we just stick to what we have, or if the user clicks reload.
                    }, 10000);
                },

                async loadInstance(instance) {
                    this.currentInstance = instance;
                    this.loading = true;
                    this.error = null;
                    this.data = null;
                    this.currentPage = 1; // Reset to first page on load

                    try {
                        const response = await fetch(`/api/analysis?path=${encodeURIComponent(instance)}`);
                        if (!response.ok) throw new Error('Failed to fetch analysis data');

                        this.data = await response.json();

                        this.$nextTick(() => {
                            this.renderCharts();
                        });

                    } catch (e) {
                        this.error = e.message;
                    } finally {
                        this.loading = false;
                    }
                },

                renderCharts() {
                    if (!this.data) return;

                    const chartColors = ['#3B82F6', '#10B981', '#F59E0B', '#EF4444', '#8B5CF6'];
                    const textColor = this.darkMode ? '#cbd5e1' : '#334155'; // slate-300 vs slate-700

                    const commonOptions = {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                position: 'right',
                                labels: { color: textColor }
                            },
                            tooltip: {
                                callbacks: {
                                    label: function (context) {
                                        let label = context.label || '';
                                        if (label) {
                                            label += ': ';
                                        }
                                        if (context.currrentParsed) { // For some charts
                                            label += context.raw;
                                        } else {
                                            // formatBytes for memory chart, number for count
                                            // Use dataset index or label to distinguish?
                                            // Actually we can just override per chart.
                                            return label + context.raw;
                                        }
                                        return label;
                                    }
                                }
                            }
                        }
                    };

                    // Type Count Chart
                    if (this.charts.typeCount) this.charts.typeCount.destroy();
                    const typeCountCtx = document.getElementById('typeCountChart').getContext('2d');
                    this.charts.typeCount = new Chart(typeCountCtx, {
                        type: 'doughnut',
                        data: {
                            labels: Object.keys(this.data.TypeNum),
                            datasets: [{
                                data: Object.values(this.data.TypeNum),
                                backgroundColor: chartColors,
                                borderWidth: 0
                            }]
                        },
                        options: {
                            ...commonOptions,
                            plugins: {
                                legend: {
                                    position: 'right',
                                    labels: { color: textColor }
                                }
                            }
                        }
                    });

                    // Type Memory Chart
                    if (this.charts.typeMem) this.charts.typeMem.destroy();
                    const typeMemCtx = document.getElementById('typeMemChart').getContext('2d');
                    this.charts.typeMem = new Chart(typeMemCtx, {
                        type: 'doughnut',
                        data: {
                            labels: Object.keys(this.data.TypeBytes),
                            datasets: [{
                                data: Object.values(this.data.TypeBytes),
                                backgroundColor: chartColors,
                                borderWidth: 0
                            }]
                        },
                        options: {
                            ...commonOptions,
                            plugins: {
                                legend: {
                                    position: 'right',
                                    labels: { color: textColor }
                                },
                                tooltip: {
                                    callbacks: {
                                        label: function (context) {
                                            return context.label + ': ' + formatBytes(context.raw);
                                        }
                                    }
                                }
                            }
                        }
                    });
                },

                formatNumber(num) {
                    return new Intl.NumberFormat().format(num);
                },

                formatDate(ts) {
                    if (!ts) return '-';
                    // Check if it's seconds or millis. RDR seems to use Millis?
                    // rdr usually stores Expiration as int64. 
                    if (ts > 1000000000000) return new Date(ts).toLocaleString();
                    return new Date(ts * 1000).toLocaleString();
                }
            }
        }

        function formatBytes(bytes, decimals = 2) {
            if (!+bytes) return '0 Bytes';
            const k = 1024;
            const dm = decimals < 0 ? 0 : decimals;
            const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return `${parseFloat((bytes / Math.pow(k, i)).toFixed(dm))} ${sizes[i]}`;
        }
    </script>
    <!-- Import Modal -->
    <div x-show="importModalOpen" class="fixed inset-0 z-50 overflow-y-auto" aria-labelledby="modal-title" role="dialog"
        aria-modal="true" style="display: none;">
        <div class="flex items-end justify-center min-h-screen pt-4 px-4 pb-20 text-center sm:block sm:p-0">

            <div x-show="importModalOpen" x-transition:enter="ease-out duration-300"
                x-transition:enter-start="opacity-0" x-transition:enter-end="opacity-100"
                x-transition:leave="ease-in duration-200" x-transition:leave-start="opacity-100"
                x-transition:leave-end="opacity-0" class="fixed inset-0 bg-gray-500 bg-opacity-75 transition-opacity"
                aria-hidden="true" @click="importModalOpen = false"></div>

            <span class="hidden sm:inline-block sm:align-middle sm:h-screen" aria-hidden="true">&#8203;</span>

            <div x-show="importModalOpen" x-transition:enter="ease-out duration-300"
                x-transition:enter-start="opacity-0 translate-y-4 sm:translate-y-0 sm:scale-95"
                x-transition:enter-end="opacity-100 translate-y-0 sm:scale-100"
                x-transition:leave="ease-in duration-200"
                x-transition:leave-start="opacity-100 translate-y-0 sm:scale-100"
                x-transition:leave-end="opacity-0 translate-y-4 sm:translate-y-0 sm:scale-95"
                class="inline-block align-bottom bg-white dark:bg-slate-800 rounded-lg text-left overflow-hidden shadow-xl transform transition-all sm:my-8 sm:align-middle sm:max-w-lg w-full">

                <div class="bg-white dark:bg-slate-800 px-4 pt-5 pb-4 sm:p-6 sm:pb-4">
                    <div class="sm:flex sm:items-start">
                        <div
                            class="mx-auto flex-shrink-0 flex items-center justify-center h-12 w-12 rounded-full bg-blue-100 dark:bg-blue-900 sm:mx-0 sm:h-10 sm:w-10">
                            <svg class="h-6 w-6 text-blue-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
                            </svg>
                        </div>
                        <div class="mt-3 text-center sm:mt-0 sm:ml-4 sm:text-left w-full">
                            <h3 class="text-lg leading-6 font-medium text-slate-900 dark:text-slate-100" id="modal-title">
                                Import from Kubernetes
                            </h3>
                            <div class="mt-4 space-y-4">

                                <div x-show="discoveryLoading" class="text-center py-4 text-slate-500">
                                    <svg class="animate-spin h-5 w-5 mx-auto mb-2 text-blue-500"
                                        xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor"
                                            stroke-width="4"></circle>
                                        <path class="opacity-75" fill="currentColor"
                                            d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z">
                                        </path>
                                    </svg>
                                    Discovering Redis resources...
                                </div>

                                <div x-show="!discoveryLoading && discoveryData.length === 0"
                                    class="text-red-500 text-sm">
                                    No Redis resources found in the cluster.
                                </div>

                                <div x-show="!discoveryLoading && discoveryData.length > 0">
                                    <!-- Namespace Select -->
                                    <div class="mb-4">
                                        <label class="block text-sm font-medium text-slate-700 dark:text-slate-300 mb-1">Namespace</label>
                                        <select x-model="selectedNamespace"
                                            class="block w-full pl-3 pr-10 py-2 text-base border-slate-300 dark:border-slate-600 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md border bg-white dark:bg-slate-700 text-slate-900 dark:text-slate-100">
                                            <template x-for="item in discoveryData" :key="item.namespace">
                                                <option :value="item.namespace" x-text="item.namespace"></option>
                                            </template>
                                        </select>
                                    </div>

                                    <!-- Pod Select -->
                                    <div class="mb-4">
                                        <label class="block text-sm font-medium text-slate-700 dark:text-slate-300 mb-1">Pod</label>
                                        <select x-model="selectedPod"
                                            class="block w-full pl-3 pr-10 py-2 text-base border-slate-300 dark:border-slate-600 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md border bg-white dark:bg-slate-700 text-slate-900 dark:text-slate-100">
                                            <option value="">Select a Pod</option>
                                            <template x-for="pod in availablePods" :key="pod">
                                                <option :value="pod" x-text="pod"></option>
                                            </template>
                                        </select>
                                    </div>

                                    <!-- Path Input -->
                                    <div class="mb-4">
                                        <label class="block text-sm font-medium text-slate-700 dark:text-slate-300 mb-1">RDB Path (in
                                            container)</label>
                                        <input type="text" x-model="importPath"
                                            class="shadow-sm focus:ring-blue-500 focus:border-blue-500 block w-full sm:text-sm border-slate-300 dark:border-slate-600 rounded-md border px-3 py-2 bg-white dark:bg-slate-700 text-slate-900 dark:text-slate-100"
                                            placeholder="/data/dump.rdb">
                                    </div>
                                </div>

                                <!-- Status Message -->
                                <div x-show="importStatus" class="mt-2 text-sm"
                                    :class="importStatus.startsWith('Error') ? 'text-red-600' : 'text-blue-600'"
                                    x-text="importStatus"></div>

                                <!-- Progress Bar -->
                                <div x-show="importing && importProgress > 0 && importProgress < 100" class="mt-4">
                                    <div class="flex justify-between mb-1">
                                        <span class="text-sm font-medium text-blue-700 dark:text-blue-500">Parsing RDB...</span>
                                        <span class="text-sm font-medium text-blue-700 dark:text-blue-500" x-text="`${Math.round(importProgress)}%`"></span>
                                    </div>
                                    <div class="w-full bg-gray-200 rounded-full h-2.5 dark:bg-gray-700">
                                        <div class="bg-blue-600 h-2.5 rounded-full transition-all duration-300 ease-out" :style="`width: ${importProgress}%`"></div>
                                    </div>
                                </div>

                            </div>
                        </div>
                    </div>
                </div>

                <div class="bg-slate-50 dark:bg-slate-700/50 px-4 py-3 sm:px-6 sm:flex sm:flex-row-reverse">
                    <button type="button" @click="startImport()" :disabled="importing || !selectedPod"
                        class="w-full inline-flex justify-center rounded-md border border-transparent shadow-sm px-4 py-2 bg-blue-600 text-base font-medium text-white hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 sm:ml-3 sm:w-auto sm:text-sm disabled:opacity-50 disabled:cursor-not-allowed">
                        <span x-show="!importing">Start Analysis</span>
                    </button>
                    <button type="button" @click="importModalOpen = false"
                        class="mt-3 w-full inline-flex justify-center rounded-md border border-slate-300 dark:border-slate-600 shadow-sm px-4 py-2 bg-white dark:bg-slate-700 text-base font-medium text-slate-700 dark:text-slate-200 hover:bg-slate-50 dark:hover:bg-slate-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 sm:mt-0 sm:ml-3 sm:w-auto sm:text-sm">
                        Cancel
                    </button>
                </div>
            </div>
        </div>
    </div>
</body>

</html>